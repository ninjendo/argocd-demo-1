To Study next: ArgoCD - https://argoproj.github.io/argo-cd/

Notes on Kubernetes >> https://www.youtube.com/watch?v=X48VuDVv0do
==================================
1. What is Microservices?
2. Master Processes 
	. API Server 
	. Scheduler
	. Controller Manager 
	. etcd - cluster brain 
		- has data 
3. Minikube
	. for testing: 1 node K8s cluster with both master and node exist on one machine
4. Kubectl
5. Install 
	. For MacOS
		. brew update 
		. brew install hyperkit 
		. brew install minikube (will install kubectl also)
		. minikube start --driver=hyperkit
			- to make hyperkit your default: minikube config set driver hyperkit
		. kubectl get nodes
		. minikube status
		. kubectl version	
	. For Windows 
		- VirtualBox/Docker for Windows (for virtualization)
			. Install Docker - https://docs.docker.com/docker-for-windows/install/
		- minikube-installer.exe (Windows standalone installer)
			. Install minikube - https://minikube.sigs.k8s.io/docs/start/
		- wsl_update_x64.exe (Windows-Linux seamless integration)
		- update to latest kubectl 
			: minikube kubectl -- get pods -A
6. Basic Kubectl commands
	=> to start minikube 
		. minikube start
	=> common view commands
		. kubectl get nodes 
			- status of different K8s components
		. kubectl get version
		. kubectl get pod 
		. kubectl get services
		. kubectl create - h 
			- create help command 
	=> Let's create deployement
		. kubectl create deployment NAME --image=image [--dry-run] [options]
		. kubectl create deployment nginx-depl --image=nginx
			- blueprint for creating pods 
			- most basic configuration for deployment (name and image to use)
			- deployment manages a replicaset
		. kubectl get deployment
		. kubectl get pod
		. kubectl get replicaset
			- replicaset is managing the replicas of a pod 
		. kubectl edit deployment [name]
	=> Let's edit deployment
		. kubectl edit deployment nginx-depl
			- old pod is terminated and new pod is running
		. kubectl get pod 
			- to see the pod running (old and new)
		. kubectl get replicaset
			- to see the old and new. old have no longer have a replicaset
	=> Let's debug pods 
		. kubectl logs [pod name]
		. kubectl logs nginx-depl-7fc44fc5d4-qgjv2
			- no lods are shown since no activity
		. kubectl create deployment mongo-depl --image=mongo
		. kubectl get pod
		. kubectl logs mongo-depl-5fd6b7d4b4-rtr8j
			- to see logs, make sure the deployment is in Running status already
		. kubectl describe pod [pod name]
			- get info about pod
		. kubectl describe pod mongo-depl-5fd6b7d4b4-rtr8j
		. kubectl exec -it [pod name] -- bin/bash
		. kubectl exec -it mongo-depl-5fd6b7d4b4-rtr8j -- bin/bash
			- command for deugging when something is not working or has problem
			- you are now inside of terminal of mongodb container
			- to exit, type: exit 
	=> Let's delete deployment
		. kubectl get deployment
			- to see deployments
		. kubectl get pod
			- to see pods 
		. kubectl delete deployment [name]
		. kubectl delete deployment mongo-depl
			- to delete deployment
		. kubectl get pod
		. kubectl get replicaset
		. kubectl delete deployment nginx-depl
		. kubectl get replicaset
			- after deleting all deployment, no resources found now
	=> Let's apply configuraion file
		. kubectl apply -f [name of config file]
		. kubectl apply -f config-file.yaml
			- this executes whatever is on the configuration file 
		. kubectl apply -f nginx-deployment.yaml
			- we need to create the file first and insert the config contents
		. kubectl delete -f [name of config file]
			- delete with configuration file
7. Configuration file
	- config file for deployment and service
	- 3 parts 
		1. metadata 
		2. specification 
		3. status 
			- automated generated by K8s
			- self-healing
			- will update the status continously
			- it comes from etcd (cluster brain)
	- format of yaml 
		. strict indentation
			- use online yaml validator
	- store the config file with your code 
	- "template" 
		. config inside config 
		. this config applies on the pod 
		. its ahs its own spec
	- metadate => labels 
	- spec => selector
	- connecting services to deployment 
		. Service 
			selector:
			   app: nginx 
		. Deployment 
			metadata:
			   labels:
			     app: nginx 
	- ports
		. Service 
			targetPort: 8080 
		. Deployment 
			containerPort: 8080
	- configure service config 
		. kubectl apply -f nginx-service.yaml 
		. kubectl get service
		. kubectl describe service nginx-service
		. kubectl get pod -o wide
			- to see the corect IPs endpoints
		. kubectl get deployment nginx-deployment -o yaml > nginx-deployment-result.yaml
			- to see the status that is autogenerated
8. Complete Demo Project 
	- will deploy mongoDB and mongoExpress
	- create: 
		. 2 deployment / pod 
		. 2 service 
		. 1 ConfigMap 
		. 1 secret
	- browser request flow thru the K8s components
		=> web browser mongo express 
			-> External Service: mongo express 
				-> Pod: mongo express 
					-> Internal Service: mongo db 
						-> Pod: mongo db 
							-> Secret: DB user/DB pass
		=> Let's start: 
			. kubectl get all
			. create Secret
				- value for username / password should be in base64
				- to make a base64, on your terminal:
					. echo -n 'username' | base64
					. echo -n 'password' | base64
				- save as mongo-secret.yaml 
				- create the Secret 
					. kubectl apply -f mongo-secret.yaml
					. kubectl get secret
			. create mongo db pod 
				- go to hub.docker.com, to get the config for mongodb image
				- port: 27017
				- variables: MONGO_INITDB_ROOT_USERNAME, MONGO_INITDB_ROOT_PASSWORD
				- we will create a Secret. this is not commited to the repository, only in K8s
				- we will refer to secret
					. use the secretKeyRef
				- lets create deployment 
					. kubectl apply -f mongo.yaml
					. kubectl get all
					. kubectl get pod
					. kubectl get pod --watch
					. kubectl describe pod mongodb-deployment-8f6675bc5-qmp6z
			. create mongo db internal service	
				- edit mongo.yaml, just add '---' at the bottom so that it is considered as separate config file 
				- lets create service config 
					. kubectl apply -f mongo.yaml
					. kubectl get service 
						- to check service created
					. kubectl describe service 
						- to see the IP & port endpoints in service 
					. kubectl get pod -o wide 
						- to see the IP of pod which is should be same with IP of services
				- Internal Service or Cluster IP is default
			. create mongo express: deployment, service and configMap
				- go to hub.docker.com, to get the config for mongo-express image
				- port: 8081
				- variables: ME_CONFIG_MONGODB_ADMINUSERNAME, ME_CONFIG_MONGODB_ADMINPASSWORD, ME_CONFIG_MONGODB_SERVER
				- we will create ConfigMap to palce the value of ME_CONFIG_MONGODB_SERVER and other env values 
				- ConfigMap must already be in the K8s cluster, when referencing it
				- lets create ConfigMap, Deploymeny and External Service 
					. kubectl apply -f mongo-configmap.yaml
						- to create configmap
					. kubectl apply -f mongo-express.yaml
						- to create mong-express deployment
					. kubectl get pod 
						- to see if its Running already
					. kubectl logs mongo-express-78fcf796b8-zv4rn
						- see the logs of the pod: mongo-express-78fcf796b8-zv4rn
				- lets create an External Service 
					. need to add "type: LoadBalancer" 
						- this assigns an external IP address and so accepts external requests
					. need to add third port, "nodePort: 30000"
						- this is the port use to access on the browser
						- it must be in between these range [30000 - 32767]
					. kubectl apply -f mongo-express.yaml
						- to create the service 
					. kubectl get service 
						- to see the services
					. minikube service mongo-express-service
						- to get the assigned external public IP address , (previously shown as <pending>
Continuation....
https://www.youtube.com/watch?v=X48VuDVv0do
1:46:16						
						
9. Namespaces
	- "default" namespace is what we have at the start
	- virtual cluster inside of a cluster
	- 4 namespaces by default
		. kubectl get namespace
		. kubectl cluster-info 
			- for kube-public namespace
	- to create namespace 
		. kubectl create namespace my-namespace
		. kubectl get namespace
	- to create namespace with configuration file
	- when to use namesapces:
		1. used to manager and grouped application by creating namespaces for each. Ex:
			- Ex: databse namespace, monitoring namespaces, logging namespaces 
		2. used when there are lots of teams but same application 
			- Ex. project A namespace, project B namespace 
		3. used when there is staging and development environmentsthat share same resources
		4. used when there are several versions: production A, production B 
		5. used to limit access. their access is only their namespace
	- to access resources from another namespace is thru the use of service 
		. Ex: 
			data:
			  db_url: mysql-service.database
	- create component in a namespace 
		. kubectl apply -f mysql-configmap.yaml
		. kubectl get configmap
			- the is the same as "kubectl get configmap -n default"
		. kubectl get configmap -n default
		. kubectl get configmap -o wide
		. kubectl get configmap -o yaml	
	- to create configmap inside a namespace 
		. kubectl apply -f mysql-configmap.yaml --namespace=my-namespace
		. kubectl get configmap -n my-namespace
		. or add this line on configmap yaml:
			namespace: my-namespace
	- to change active namespace, install "kubens"		
		=> for MacOS
			. brew install kubectx 
			. kubens
				- to list namespaces with the active as highlighted 
			. kubens my-namespace 
				- to set the new active namespace 
		=> for Windows, 
			. download kubenswin at https://github.com/thomasliddledba/kubenswin
			. add kubenswin.exe to environment variables
			. kubenswin ls
				- to list namespaces with the active as highlighted 
			. kubenswin set my-namespace 
				- to set the new active namespace 

10. K8s Ingress
	- Ingress is used to fix https://111.222.333.444:30000 to https://my-app.com 
	- https://my-app.com 
		-> my-app Ingress 
			-> my-app service (internal)
				-> my-app pod
	- Extrnal Service VS Ingress 
		. External service YAML has: [https://111.222.333.444:35010]
			kind: Service 
			..
			type: LoadBalancer 
			..
			nodePort: 35010
		. Ingress YAML  has: [http://my-app.com:8080] not https yet!!!
			apiVersion: networking.k8s.io/v1beta1
			kind: Ingress 
			metadate:
			  name: myapp-ingress
			spec:
			  rules:
			    - host: myapp.com 
			    http:
			      paths:
				  - backend:
				      serviceName: my-app-internal-service 
					  servicePort: 8080
			
			-> note: servicePort: 8080 corresponds to "port:8080" not "targetPort:8080"		
	- host:
		. valid domain address 
		. map domain name to NOde's IP address, which is the entrypoint
	- to configure Ingress in your cluster 
		. we need Ingress Controller pod
			- this evaluates and controls Ingress all rules and manages redirection
			- this is the entrypoint to cluster
		. to install Ingress Controller
			- there are other 3rd party ingress controller 
			- but we have already inside K8s ---> Nginx Ingress Controller
	- setup using cloud environment like AWS:
		=> https://my-app.com (external request) 
			-> AWS Cloud Load balancer 
				-> K8s Ingress Controller pod
					-> my-app Ingress 
						-> my-app service (internal)
							-> my-app pod
	- setup using Bare Metal:
		=> https://my-app.com (external request)
			-> Proxy Server (separate server) 
				-> AWS Cloud Load balancer 
					-> K8s Ingress Controller pod
						-> my-app Ingress 
							-> my-app service (internal)
								-> my-app pod
	- setup using Minikube: (local laptop)
		. minikube addons enable ingress 
			- to install Ingress Controller
			- it automatically start the K8s Nginx implementation of Ingress Controller
			- after the addon is enabled, please run "minikube tunnel" and your ingress resources would be available at "127.0.0.1"
		. kubectl get pod -n kube-system 
			- to see the nginx-ingress-controller pod running in your cluster
		. to create ingress rule for the controller to evaluate
			- kubectl get ns 
			- kubectl get all -n kubernetes-dashbboard
			- kubectl apply -f dashboard-ingress.yaml
				. note: namespace should be same as service name and pod name
			- kubectl get ingress -n kubernetes-dashboard --watch
			- sudo vim /etc/hosts 
				. to define the hostname mapping
				. you can now check on browser: http://dashbpard.com
			- kubectl describe ingress dashbooard-ingress -n kubernetes-dashboard
		=> https://dashboard.com (external request) --> see video tutorial: 2:16:42
			-> Proxy Server (separate server) 
				-> AWS Cloud Load balancer 
					-> K8s Ingress Controller pod
						-> my-app Ingress 
							-> my-app service (internal)
								-> my-app pod			
	- setup multiple path on same host --> see video tutorial: 2:20:20
				
								
Continuation....
https://www.youtube.com/watch?v=X48VuDVv0do&t=6372s
2:20:20


-----------------------


Notes on ArgoCD (tutorial: https://www.youtube.com/watch?v=vSnVhJkyJBw&t=6s)
================
1. Metrics 
	- https://argoproj.github.io/argo-cd/operator-manual/metrics/
	- https://argoproj.github.io/argo-cd/operator-manual/metrics/#api-server-metrics
2. Deploy ArgoCD on Kubernetes
	. install argocd CLI, go to: https://github.com/argoproj/argo-cd/releases/tag/v2.0.1
		- argocd-windows-amd64.exe
			. add this to your windows path environment
		- argocd-util-windows-amd64.exe
	. go to: https://github.com/argoproj/argo-cd/releases/tag/v2.0.1
		- kubectl create namespace argocd
			. create namespace 
		- kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/v2.0.1/manifests/install.yaml
			. to deploy all the resources
		- kubectl -n argocd get all
		- kubectl -n argocd edit svc argocd-server
			. to change the type from CLusterIP to NodePort
		- kubectl -n argocd get all
			. it shows:
				service/argocd-server           NodePort    10.98.182.121    <none>        80:30004/TCP,443:30886/TCP   8m34s
	. lets access the argocd 
		- kubectl get nodes -o wide
			. to see the ip address of our worker node 
			.  192.168.49.2: 30004
		- minikube service argocd-server -n argocd	
			. to run our argocd
			|-----------|---------------|-------------|---------------------------|
			| NAMESPACE |     NAME      | TARGET PORT |            URL            |
			|-----------|---------------|-------------|---------------------------|
			| argocd    | argocd-server | http/80     | http://192.168.49.2:30004 |
			|           |               | https/443   | http://192.168.49.2:30886 |
			|-----------|---------------|-------------|---------------------------|
			* Starting tunnel for service argocd-server.
			|-----------|---------------|-------------|------------------------|
			| NAMESPACE |     NAME      | TARGET PORT |          URL           |
			|-----------|---------------|-------------|------------------------|
			| argocd    | argocd-server |             | http://127.0.0.1:64035 |
			|           |               |             | http://127.0.0.1:64036 |
			|-----------|---------------|-------------|------------------------|
		- For Argo CD v1.8 and earlier, the initial password is set to the name of the server pod, as per the getting started guide. For Argo CD v1.9 and later, the initial password is available from a secret named argocd-initial-admin-secret.
			. we are using argocd 2.0.1 already
		- to change password:
			. go to https://www.browserling.com/tools/bcrypt and bcrypt your new password
				Ex: anotherpassword = $2a$10$NgxYT6/0yc32uKlwUPSEYuHTt7G7toxhKoRttTWEU.i5NGH4y1yXG
			. or go here: 
https://www.devglan.com/online-tools/bcrypt-hash-generator#:~:text=As%20per%20wiki%2C%20Bcrypt%20is,way%20hash%20of%20the%20password.
			. then enter this command:
				kubectl -n argocd patch secret argocd-secret -p '"stringData": { "admin.password": "$2a$10$NgxYT6/0yc32uKlwUPSEYuHTt7G7toxhKoRttTWEU.i5NGH4y1yXG", "admin.passwordMtime": "2021-05-18T21:20:20+08:00"}'
		- login: admin / anotherpassword
	. Connect your repo on ArgoCD 
		- repo url: https://github.com/artotoy/argocd-demo
		- select Connect repo using HTTPS	
		- to run our ngix app: 
			. minikube service nginx-service -n default
				|-----------|---------------|-------------|---------------------------|
				| NAMESPACE |     NAME      | TARGET PORT |            URL            |
				|-----------|---------------|-------------|---------------------------|
				| default   | nginx-service |          80 | http://192.168.49.2:31965 |
				|-----------|---------------|-------------|---------------------------|
				* Starting tunnel for service nginx-service.
				|-----------|---------------|-------------|------------------------|
				| NAMESPACE |     NAME      | TARGET PORT |          URL           |
				|-----------|---------------|-------------|------------------------|
				| default   | nginx-service |             | http://127.0.0.1:65419 |
				|-----------|---------------|-------------|------------------------|
	. lets add more replicas 
		- kubectl scale deploy nginx --replicas 2
		- kubectl get all
		
Deleting ArgoCD
			. kubectl delete -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
		
		
		
		
		
		
		
		
		
		
		
			
		